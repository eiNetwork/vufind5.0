<?php

/**
 * EINetwork-specific adaptation of SierraRest ILS driver
 */

namespace VuFind\ILS\Driver;

use Memcached;
use SoapClient;

class EINetwork extends SierraRest implements
    \VuFind\Db\Table\DbTableAwareInterface
{
    use \VuFind\Db\Table\DbTableAwareTrait;

    protected $memcached = null;

    /**
     * Record loader
     *
     * @var \VuFind\Record\Loader
     */
    protected $recordLoader;

    /**
     * Overdrive Connector
     *
     * @var \VuFind\DigitalContent\OverdriveConnector $connector Overdrive Connector
     */
    protected $connector;

    /**
     * Mappings from item status codes to VuFind strings
     *
     * @var array
     */
    protected $itemStatusMappings = [
        '!' => 'ON HOLDSHELF',
        't' => 'IN TRANSIT',
        'o' => 'NONCIRCULATING',
        'k' => 'REPAIR',
        'm' => 'MISSING',
        'n' => 'BILLED',
        '$' => 'LOST AND PAID',
        'p' => 'DISPLAY',
        'z' => 'CLMS RETD',
        's' => 'ON SEARCH',
        'd' => 'DAMAGED',
        'q' => 'BINDERY',
        '%' => 'ILL RETURNED',
        'f' => 'LONG OVERDUE',
        '$' => 'LOST AND PAID',
        'v' => 'ONLINE',
        'y' => 'ONLINE REFERENCE',
        '^' => 'RENOVATION',
        'r' => 'REPAIR',
        'u' => 'STAFF USE',
        '?' => 'STORAGE',
        'w' => 'ILL RETURNED',
        'i' => 'IN PROCESSING',
        'order' => 'ON ORDER'
    ];
    protected $itemStatusReverseMappings;

    /**
     * Constructor
     *
     * @param \VuFind\Date\Converter $dateConverter  Date converter object
     * @param \VuFind\Record\Loader  $loader         Record Loader object
     * @param Callable               $sessionFactory Factory function returning
     * SessionContainer object
     */
    public function __construct(\VuFind\Date\Converter $dateConverter, \VuFind\Record\Loader $loader,
        $sessionFactory, $ODconnector
    ) {
        $this->dateConverter = $dateConverter;
        $this->recordLoader = $loader;
        $this->sessionFactory = $sessionFactory;
        $this->connector = $ODconnector;
    }

    /**
     * Initialize the driver.
     *
     * Validate configuration and perform all resource-intensive tasks needed to
     * make the driver active.
     *
     * @throws ILSException
     * @return void
     */
    public function init()
    {
        parent::init();

        // start memcached
        $this->memcached = new Memcached();
        $this->memcached->addServer('localhost', 11211);
        if( !$this->memcached->get("globalRefreshTimer") ) {
            $this->memcached->set("globalRefreshTimer", time());
        }

        $this->itemStatusReverseMappings = array_flip($this->itemStatusMappings);
        $this->itemStatusReverseMappings['AVAILABLE'] = "-";
        $this->itemStatusReverseMappings['CHECKED OUT'] = "-";
    }

    /**
     * Test Session
     *
     * This checks the session to ensure it isn't outdated, either from being too old or being generated by an older version of the code.
     *
     * @param string $id The record id to test the bibLevel
     *
     * @return bool  Whether or not this bib is a serial type (used to determine if we need to look for checkin records)
     */
    public function testSession()
    {
        if( (isset($this->sessionCache->sessionExpiration) && ($this->sessionCache->sessionExpiration < time())) || 
            (isset($this->sessionCache->memCacheRefreshTimer) && ($this->memcached->get("globalRefreshTimer") != $this->sessionCache->memCacheRefreshTimer)) ) {
            unset($this->sessionCache->checkouts);
            unset($this->sessionCache->holds);
            unset($this->sessionCache->patron);
            unset($this->sessionCache->readingHistory);
            unset($this->sessionCache->readingHistoryPartial);
            unset($this->sessionCache->memCacheRefreshTimer);
            unset($this->sessionCache->sessionExpiration);
        }

        // now fix these if they haven't been set yet
        if( !isset($this->sessionCache->memCacheRefreshTimer) ) {
            $this->sessionCache->memCacheRefreshTimer = $this->memcached->get("globalRefreshTimer");
        }
        if( !isset($this->sessionCache->sessionExpiration) ) {
            $this->sessionCache->sessionExpiration = time() + 1800;
        }
    }

    public function getSessionVar($name) {
        return isset($this->sessionCache[$name]) ? $this->sessionCache[$name] : null;
    }

    public function setSessionVar($name, $value) {
        $this->sessionCache[$name] = $value;
    }

    public function clearSessionVar($name) {
        unset($this->sessionCache[$name]);
    }

    public function getMemcachedVar($name) {
        return $this->memcached->get($name);
    }

    public function setMemcachedVar($name, $value, $time=null) {
        if( $time ) {
            $this->memcached->set($name, $value, $time);
        } else {
            $this->memcached->set($name, $value);
        }
    }

    public function clearMemcachedVar($name) {
        return $this->memcached->delete($name);
    }



    public function getClassicLink($bib) {
        return $this->config["Catalog"]["classic_url"] . "/record=" . ((substr($bib, 0, 2) == ".b") ? substr($bib, 1, -1) : $bib);
    }

    public function getCurrentLocation() {
        $myIP = isset($_SERVER['HTTP_X_FORWARDED_FOR']) ? $_SERVER['HTTP_X_FORWARDED_FOR'] : $_SERVER['REMOTE_ADDR'];
        if( !$this->memcached->get("locationByIP" . $myIP) ) {
            $this->memcached->set("locationByIP" . $myIP, $this->getDbTable('Location')->getCurrentLocation($myIP));
        }
        return $this->memcached->get("locationByIP" . $myIP);
    }

    public function getHolding($id, array $patron = null)
    {
        $driver = $this->recordLoader->load($id);

        // see if it's there
        if( ($overDriveId = $this->getOverDriveID($id)) ) {
            $availability = $driver->getOverdriveAvailability();
            return [["id" => $id,
                     "location" => "OverDrive",
                     "locationID" => null,
                     "isOverDrive" => true,
                     "isOneClick" => false,
                     "copiesOwned" => $availability->data->copiesOwned,
                     "copiesAvailable" => $availability->data->copiesAvailable,
                     "numberOfHolds" => $availability->data->numberOfHolds,
                     "availability" => ($availability->data->copiesAvailable > 0)
                   ]];
        }

        $cachedInfo = ($this->memcached->get("holdingID" . $id) && ($this->memcached->get("holdingID" . $id))["CACHED_INFO"]) ? ($this->memcached->get("holdingID" . $id))["CACHED_INFO"] : null;
        if( $cachedInfo && !$cachedInfo["doUpdate"] && isset($cachedInfo["holding"]) ) {
            $results = $cachedInfo["holding"];

            // if we haven't processed these holdings yet, run through the order records
            if( !isset($cachedInfo["processedHoldings"]) && ($cachedJson = $this->memcached->get("cachedJson" . $id)) !== null ) {
                if( isset($cachedJson["orderRecords"]) ) {
                    foreach( $cachedJson["orderRecords"] as $locationID => $details ) {
                        $results[] = [
                                         "id" => $id,
                                         "item_id" => null,
                                         "availability" => false,
                                         "statusCode" => "order",
                                         "status" => $this->itemStatusMappings["order"],
                                         "location" => $details["location"],
                                         "reserve" => "N",
                                         "callnumber" => null,
                                         "duedate" => null,
                                         "returnDate" => false,
                                         "number" => null,
                                         "barcode" => null,
                                         "locationID" => $locationID,
                                         "copiesOwned" => $details["copies"]
                                     ];
                    }
                }
            }

            // if they don't have a status string yet, we need to add that in
            foreach( $results as $key => $thisResult ) {
                if( !isset($thisResult["status"]) ) {
                    $thisResult["status"] = ($thisResult["statusCode"] == "-") ? ($thisResult["duedate"] ? "CHECKED OUT" : "AVAILABLE") : $this->itemStatusMappings[$thisResult["statusCode"]];
                    $results[$key] = $thisResult;
                }
            }
        } else {
            $results = parent::getHolding($id, $patron);

            // add the cached order records
            if( ($cachedInfo = $driver->getCachedItems()) !== null ) {
                if( isset($cachedInfo["orderRecords"]) ) {
                    foreach( $cachedInfo["orderRecords"] as $locationCode => $details ) {
                        $details["id"] = substr($details["id"], 2, -1);
                        $details["locationID"] = $locationCode;
                        $details["callnumber"] = $details["callnumber"] ?? "";
                        $details["number"] = $details["number"] ?? "";
                        $results[] = $details;
                    }
                }
            }
        }

        // make any status updates we are supposed to be making
        if( $changes = $this->memcached->get("updatesID" . $id) ) {
            foreach( $changes as $key => $thisChange ) {
                // if they've already been taken care of, ignore them
                if( !$thisChange["handled"] ) {
                    foreach( $results as $hKey => $thisHolding ) {
                        if( $thisHolding["item_id"] == $thisChange["inum"] ) {
                            if( isset($thisChange["statusCode"]) ) {
                                $thisHolding["statusCode"] = $thisChange["statusCode"];
                            }
                            if( isset($thisChange["duedate"]) ) {
                                $thisHolding["duedate"] = ($thisChange["duedate"] != "NULL") ? strftime("%m-%d-%y", strtotime($thisChange["duedate"])) : null;
                                $thisHolding["availability"] = ((($thisChange["statusCode"] ?? "") == "-") && !$thisHolding["duedate"]);
                            }
                            $results[$hKey] = $thisHolding;
                        }
                    }
                }
            }
            if( ($cache = $this->memcached->get("holdingID" . $id)) && isset($cache["CACHED_INFO"]["holding"]) ) {
                $cache["CACHED_INFO"]["holding"] = $results;
                $time = strtotime(((date("H") < "06") ? "today" : "tomorrow") . " 6:00") - time();
                $this->memcached->set("holdingID" . $id, $cache, $time);
            }
        }

        // add in the extra details we need
        $results2 = [];
        for($i=0; $i<count($results); $i++) {
            // throw out online items
            if( $results[$i]['locationID'] == "xronl" ) {
                continue;
            }

            // clean call number
            $pieces = explode("|f", $results[$i]['callnumber']);
            $results[$i]['callnumber'] = "";
            foreach( $pieces as $piece ) {
                $results[$i]['callnumber'] .= (($results[$i]['callnumber'] == "") ? "" : "<br>") . trim($piece);
            }
            if( isset($results[$i]['item_notes']) ) {
                foreach( $results[$i]['item_notes'] as $note ) {
                    $results[$i]['callnumber'] .= (($results[$i]['callnumber'] == "") ? "" : "<br>") . $note;
                }
            }

            // get shelving details
            if( !$this->memcached->get("shelvingLocationByCode" . $results[$i]['locationID']) ) {
                $this->memcached->set("shelvingLocationByCode" . $results[$i]['locationID'], $this->getDBTable('shelvinglocation')->getByCode($results[$i]['locationID']));
            }
            $shelfLoc = $this->memcached->get("shelvingLocationByCode" . $results[$i]['locationID'] );
            $locationId = (isset($shelfLoc) && $shelfLoc) ? $shelfLoc->locationId : null;
            if( $locationId && !$this->memcached->get("locationByID" . $locationId) ) {
                $this->memcached->set("locationByID" . $locationId, $this->getDBTable('location')->getByLocationId($locationId));
            } else if( !$locationId && (strlen($results[$i]['locationID']) == 2) && !$this->memcached->get("locationByCode" . $results[$i]['locationID']) ) {
                $this->memcached->set("locationByCode" . $results[$i]['locationID'], $this->getDBTable('location')->getByCode($results[$i]['locationID']));
            }
            $location = $locationId ? $this->memcached->get("locationByID" . $locationId ) : ((strlen($results[$i]['locationID']) == 2) ? $this->memcached->get("locationByCode" . $results[$i]['locationID']) : null);
            $results[$i]['branchName'] = $location ? $location->displayName : (($results[$i]['statusCode'] == 'order') ? $results[$i]['locationID'] : null);
            $results[$i]['branchCode'] = $location ? $location->code : null;
            $results[$i]['shelvingLocation'] = $shelfLoc ? $shelfLoc->shortName : null;
            $results[$i]['sierraLocation'] = $shelfLoc ? $shelfLoc->sierraName : null;

            for($j=0; $j<count($results2) && (($results[$i]['branchName'] > $results2[$j]['branchName']) || (($results[$i]['branchName'] == $results2[$j]['branchName']) && ($results[$i]['number'] > $results2[$j]['number']))); $j++) {}
            array_splice($results2, $j, 0, [$results[$i]]);
        }

        // if this is a magazine, we need to add the checkin records info
        if( $this->isSerial($id) ) {
            // get all of the locations we need to speak for
            $neededLocations = [];
            foreach( $results2 as $thisItem ) {
                if( !isset($neededLocations[$thisItem["locationID"]]) ) {
                    $neededLocations[$thisItem["locationID"]] = $thisItem["locationID"];
                }
            }

            // grab the checkin records and store the location info
            $results3 = [];
            if( $cachedInfo && !$cachedInfo["doUpdate"] && isset($cachedInfo["checkinRecords"]) ) {
                $checkinRecords = $cachedInfo["checkinRecords"];
            } else {
                $checkinRecords = $driver->getCachedItems()["checkinRecords"] ?? [];
            }

            foreach( array_keys($checkinRecords) as $key ) {
                // find this location in the database
                if( !$this->memcached->get("shelvingLocationBySierraName" . md5($checkinRecords[$key]["location"])) ) {
                    $this->memcached->set("shelvingLocationBySierraName" . md5($checkinRecords[$key]["location"]), $this->getDBTable('shelvinglocation')->getBySierraName($checkinRecords[$key]["location"])->toArray());
                }
                $checkinRecords[$key]["code"] = [];
                $checkinRecords[$key]["branchCode"] = [];
                foreach( $this->memcached->get("shelvingLocationBySierraName" . md5($checkinRecords[$key]["location"])) as $row ) {
                    $checkinRecords[$key]["code"][] = $row["code"];
                    $checkinRecords[$key]["branchCode"][] = $row["branchCode"];
                    unset($neededLocations[$row["code"]]);
                }
                for( $j=0; $j<count($results3) && ($results3[$j]['location'] < $checkinRecords[$key]["location"]); $j++) {}
                array_splice($results3, $j, 0, [$checkinRecords[$key]]);
            }

            // add details for locations with no checkin records but held items
            foreach( $neededLocations as $code ) {
                if( !$this->memcached->get("shelvingLocationByCode" . $code) ) {
                    $this->memcached->set("shelvingLocationByCode" . $code, $this->getDBTable('shelvinglocation')->getByCode($code));
                }
                $shelfLoc = $this->memcached->get("shelvingLocationByCode" . $code );
                if( $shelfLoc == null ) {
                    if( !$this->memcached->get("locationByCode" . $code) ) {
                        $this->memcached->set("locationByCode" . $code, $this->getDBTable('location')->getByCode($code));
                    }
                    $shelfLoc = $this->memcached->get("locationByCode" . $code );
                }
                $thisCode = [];
                $thisCode["location"] = isset($shelfLoc->sierraName) ? $shelfLoc->sierraName : $shelfLoc->displayName;
                $thisCode["code"][] = $code;
                $thisCode["branchCode"][] = isset($shelfLoc->branchCode) ? $shelfLoc->branchCode : $code;
                for( $j=0; $j<count($results3) && ($results3[$j]['location'] < $thisCode["location"]); $j++) {}
                array_splice($results3, $j, 0, [$thisCode]);
                unset($neededLocations[$code]);
            }

            array_splice($results2, 0, 0, [["id" => $id, "location" => "CHECKIN_RECORDS", "availability" => false, "statusCode" => "?", "status" => "?", "items" => [], "copiesOwned" => 0, "checkinRecords" => $results3]]);
        }
        return $results2;
    }

    /**
     * Patron Login
     *
     * This is responsible for authenticating a patron against the catalog.
     *
     * @param string $username The patron username
     * @param string $password The patron password
     *
     * @return mixed           Associative array of patron info on successful login,
     * null on unsuccessful login.
     *
     * @SuppressWarnings(PHPMD.UnusedFormalParameter)
     */
    public function patronLogin($username, $password)
    {
        if( $cachedInfo = $this->sessionCache->patronLogin ) {
            return $cachedInfo;
        }

        $results = parent::patronLogin($username, $password);

        $this->sessionCache->patronLogin = $results;
        return $results;
    }

    /**
     * Get Patron Profile
     *
     * This is responsible for retrieving the profile for a specific patron.
     *
     * @param array $patron The patron array
     *
     * @throws ILSException
     * @return array        Array of the patron's profile data on success.
     */
    public function getMyProfile($patron, $forceReload=false)
    {
        $this->testSession();

        if( !$forceReload && $this->sessionCache->patron ) {
            return $this->sessionCache->patron;
        }

        $patron = parent::getMyProfile($patron);

        $patron['showTemporaryClosureMessage'] = false;
        if( !$this->memcached->get("locationByCode" . $patron['homelibrarycode']) ) {
            $this->memcached->set("locationByCode" . $patron['homelibrarycode'], $this->getDbTable('Location')->getByCode($patron['homelibrarycode']));
        }
        $location = $this->memcached->get("locationByCode" . $patron['homelibrarycode']);
        $patron['homelibrary'] = ($location != null && $location->validHoldPickupBranch) ? $location->displayName : null;
        $patron['showTemporaryClosureMessage'] |= ($location != null && ($location->validHoldPickupBranch == 2));
        if( !$patron['homelibrary'] ) {
            $patron['homelibrarycode'] = null;
        }

        $user = $this->getDbTable('user')->getByUsername($patron['username'], false);

        $patron['preferredlibrarycode'] = $user->preferred_library;
        if( !$this->memcached->get("locationByCode" . $patron['preferredlibrarycode']) ) {
            $this->memcached->set("locationByCode" . $patron['preferredlibrarycode'], $this->getDbTable('Location')->getByCode($patron['preferredlibrarycode']));
        }
        $location = $this->memcached->get("locationByCode" . $patron['preferredlibrarycode']);
        $patron['preferredlibrary'] = ($location != null && $location->validHoldPickupBranch) ? $location->displayName : null;
        $patron['showTemporaryClosureMessage'] |= ($location != null && ($location->validHoldPickupBranch == 2));
        if( !$patron['preferredlibrary'] ) {
            $patron['preferredlibrarycode'] = null;
        }

        $patron['alternatelibrarycode'] = $user->alternate_library;
        if( !$this->memcached->get("locationByCode" . $patron['alternatelibrarycode']) ) {
            $this->memcached->set("locationByCode" . $patron['alternatelibrarycode'], $this->getDbTable('Location')->getByCode($patron['alternatelibrarycode']));
        }
        $location = $this->memcached->get("locationByCode" . $patron['alternatelibrarycode'] );
        $patron['alternatelibrary'] = ($location != null && $location->validHoldPickupBranch) ? $location->displayName : null;
        $patron['showTemporaryClosureMessage'] |= ($location != null && ($location->validHoldPickupBranch == 2));
        if( !$patron['alternatelibrary'] ) {
            $patron['alternatelibrarycode'] = null;
        }

        // overdrive info
        $lendingOptions = $this->connector->getLendingOptions();
        $patron['OD_eBook'] = $lendingOptions["eBook"];
        $patron['OD_audiobook'] = $lendingOptions["Audiobook"];
        $patron['OD_video'] = $lendingOptions["Video"];
        $patron['OD_renewalInDays'] = $lendingOptions["renewalInDays"];
        $patron['splitEcontent'] = $user->splitEcontent;

        $this->sessionCache->patron = $patron;

        return $patron;
    }


    public function updateMyProfile($patron, $updatedInfo){
        // update the phone, email, and/or notification setting
        if( isset($updatedInfo['phones']) || isset($updatedInfo['emails']) || isset($updatedInfo['pin']) || isset($updatedInfo['notices']) ) {
            // flip this setting into the correct fixedField
            if( isset($updatedInfo['notices']) ) {
                if( ($updatedInfo['notices'] == "p") && (!isset($patron["phone"]) || !$patron["phone"]) ) {
                    return ["success" => false, "error" => "preference_no_phone"];
                } else if( ($updatedInfo['notices'] == "z") && (!isset($patron["email"]) || !$patron["email"]) ) {
                    return ["success" => false, "error" => "preference_no_email"];
                }

                $updatedInfo["fixedFields"] = ["268" => ["label" => "Notice Preference", "value" => $updatedInfo['notices']]];
                unset($updatedInfo['notices']);
            }

            $result = $this->makeRequest(
                ['v5', 'patrons', $patron['id']],
                json_encode($updatedInfo),
                'PUT',
                $patron
            );
            return ["success" => (!isset($result["code"]) && !isset($result["specificCode"]))];
        }

        // see whether they have given us an updated preferred library
        if( isset($updatedInfo['preferred_library']) ) {
            $user = $this->getDbTable('user')->getByUsername($patron['username'], false);
            $user->changePreferredLibrary($updatedInfo['preferred_library']);
        }

        // see whether they have given us an updated alternate library
        if( isset($updatedInfo['alternate_library']) ) {
            $user = $this->getDbTable('user')->getByUsername($patron['username'], false);
            $user->changeAlternateLibrary($updatedInfo['alternate_library']);
        }

        // see whether they have given us a new splitEcontent preference
        if( isset($updatedInfo['splitEcontent']) ) {
            $user = $this->getDbTable('user')->getByUsername($patron['username'], false);
            $user->changeSplitEcontent($updatedInfo['splitEcontent']);
        }

        // see whether they have updated their overdrive lending periods
        $formats = array("ebook", "audiobook", "video");
        foreach( $formats as $thisFormat ) {
            if( isset($updatedInfo[$thisFormat]) ) {
                $lendInfo = array("format" => $thisFormat,
                                  "days" => $updatedInfo[$thisFormat] );
                $this->connector->setLendingOption($lendInfo);
            }
        }

        unset($this->sessionCache->patron);
        $this->getMyProfile($patron);
    }

    /**
     * Get Number of My Transactions
     *
     * This is responsible for returning the raw count of a patron's checked out items.
     *
     * @param string $patron The patron's id
     *
     * @throws ILSException
     * @return int           Count of checked out items.
     */
    public function getNumberOfMyTransactions($patron){
        if( isset($this->sessionCache->checkouts) ) {
            return count($this->sessionCache->checkouts);
        }

        // get count of sierra checkouts
        $result = $this->makeRequest(
            ['v5', 'patrons', $patron['id'], 'checkouts'],
            ['limit' => 1, 'offset' => 0],
            'GET',
            $patron
        );
        $numberOfSierraTransactions = $result["total"];

        // get count of overdrive checkouts
        $numberOfOverDriveTransactions = count($this->connector->getCheckouts(true)->data);

        // return the sum
        return $numberOfSierraTransactions + $numberOfOverDriveTransactions;
    }

    /**
     * Get Patron Transactions
     *
     * This is responsible for retrieving all transactions (i.e. checked out items)
     * by a specific patron.
     *
     * @param array $patron The patron array from patronLogin
     *
     * @throws DateException
     * @throws ILSException
     * @return array        Array of the patron's transactions on success.
     */
    public function getMyTransactions($patron, $skipCache=false)
    {
        $this->testSession();

        if( isset($this->sessionCache->checkouts) && !isset($this->sessionCache->staleCheckoutsHash) && !$skipCache ) {
            return $this->sessionCache->checkouts;
        // clear out these intermediate cached API results
        } else {
            $hierarchy = ['v' . $this->apiVersion, 'patrons', $patron['id'], 'checkouts'];
            $hash = md5(json_encode($hierarchy) . "###" . json_encode($this->checkoutParams));
            $this->memcached->set($hash, null);
        }

        $sierraTransactions = parent::getMyTransactions($patron);

        // fill in this value
        foreach( $sierraTransactions as $key => $thisCheckout ) {
            $sierraTransactions[$key]["fullID"] = ".b" . $thisCheckout["id"] . $this->getCheckDigit($thisCheckout["id"]);
        }

        // get overdrive checkouts
        $overDriveTransactions = json_decode(json_encode($this->connector->getCheckouts(true)), true)["data"];
        foreach($overDriveTransactions as $item) {
            $solrInfo = $this->getSolrRecordFromExternalId($item["reserveId"]);
            if($solrInfo) {
                foreach($solrInfo as $key => $value) {
                    $item[$key] = $value;
                }
                $item['fullID'] = $item['id'];
                $item['duedate'] = $item['expires'];
                $item['ILL'] = false;
                $item['overdriveListen'] = false;
                $item['overdriveRead'] = false;
                $item['mediaDo'] = false;
                $item['streamingVideo'] = false;
                $item['downloadable'] = false;

                // get the list of available formats
                $item['availableFormats'] = [];
                foreach($item["formats"] ?? [] as $thisFormat) {
                    $item['availableFormats'][] = $thisFormat["formatType"];
                }
                foreach($item["actions"]["format"]["fields"] ?? [] as $thisFormat) {
                    if( $thisFormat["name"] == "formatType" ) {
                        $item['availableFormats'] = array_merge($item['availableFormats'], $thisFormat["options"]);
                    }
                }

                // look for download links
                $OD_type_mapping = ['ebook-mediado' => 'mediaDo', 'ebook-overdrive' => 'overdriveRead', 'magazine-overdrive' => 'overdriveRead', 'video-streaming' => 'streamingVideo', 'audiobook-overdrive' => 'overdriveListen'];
                foreach( $OD_type_mapping as $formatType => $linkKey ) {
                    if( in_array($formatType, $item['availableFormats']) && ($item["formats"] ?? false) ) {
                        $item[$linkKey] = $this->connector->getDownloadLink($item["reserveId"], $formatType, $this->config["Site"]["url"]);
                    }
                }

                $sierraTransactions[] = $item;
            }
        }

        $this->sessionCache->checkouts = $sierraTransactions;
        if( isset($this->sessionCache->staleCheckoutsHash) ) {
            if( md5(json_encode($sierraTransactions)) != $this->sessionCache->staleCheckoutsHash ) {
                unset( $this->sessionCache->staleCheckoutsHash );
            }
        }

        return $this->sessionCache->checkouts;
    }

    /**
     * Renew My Items
     *
     * Function for attempting to renew a patron's items.  The data in
     * $renewDetails['details'] is determined by getRenewDetails().
     *
     * @param array $renewDetails An array of data required for renewing items
     * including the Patron ID and an array of renewal IDS
     *
     * @return array              An array of renewal information keyed by item ID
     */
    public function renewMyItems($renewDetails)
    {
        // this should change their checkouts, so throw out the cached info
        unset($this->sessionCache->checkouts);

        return parent::renewMyItems($renewDetails);
    }

    /**
     * Get Number of My Holds
     *
     * This is responsible for returning the raw count of a patron's holds.
     *
     * @param string $patron The patron's id
     *
     * @throws ILSException
     * @return int           Count of holds.
     */
    public function getNumberOfMyHolds($patron){
        if( isset($this->sessionCache->holds) ) {
            return count($this->sessionCache->holds);
        }

        // get count of sierra holds
        $result = $this->makeRequest(
            ['v5', 'patrons', $patron['id'], 'holds'],
            ['limit' => 1, 'offset' => 0],
            'GET',
            $patron
        );
        $numberOfSierraHolds = $result["total"];

        // get count of overdrive holds
        $numberOfOverDriveHolds = count($this->connector->getHolds(true)->data);

        // return the sum
        return $numberOfSierraHolds + $numberOfOverDriveHolds;
    }

    /**
     * Get Patron Holds
     *
     * This is responsible for retrieving all holds by a specific patron.
     *
     * @param array $patron The patron array from patronLogin
     *
     * @throws DateException
     * @throws ILSException
     * @return array        Array of the patron's holds on success.
     * @todo   Support for handling frozen and pickup location change
     */
    public function getMyHolds($patron, $skipCache=false)
    {
        $this->testSession();

        if( isset($this->sessionCache->holds) && !isset($this->sessionCache->staleHoldsHash) && !$skipCache ) {
            return $this->sessionCache->holds;
        // clear out these intermediate cached API results
        } else {
            $hierarchy = ['v' . $this->apiVersion, 'patrons', $patron['id'], 'holds'];
            $hash = md5(json_encode($hierarchy) . "###" . json_encode($this->holdParams));
            $this->memcached->set($hash, null);
        }

        $sierraHolds = parent::getMyHolds($patron);

        // fill in these values
        foreach( $sierraHolds as $key => $thisHold ) {
            $sierraHolds[$key]["locationID"] = $sierraHolds[$key]["location"];
            if( !$this->memcached->get("locationByCode" . $sierraHolds[$key]["locationID"]) ) {
                $this->memcached->set("locationByCode" . $sierraHolds[$key]["locationID"], $this->getDbTable('Location')->getByCode($sierraHolds[$key]["locationID"]));
            }
            $location = $this->memcached->get("locationByCode" . $sierraHolds[$key]["locationID"] );
            $sierraHolds[$key]["location"] = $location->holdingBranchLabel;
        }

        $overDriveHolds = json_decode(json_encode($this->connector->getHolds(true)), true)["data"];
        foreach($overDriveHolds as $hold) {
            $solrInfo = $this->getSolrRecordFromExternalId($hold["reserveId"]);
            if($solrInfo) {
                foreach($solrInfo as $key => $value) {
                    $hold[$key] = $value;
                }
                $hold['available'] = isset($hold["actions"]["checkout"]);
                $hold['in_transit'] = false;
                $hold['requestId'] = "OverDrive" . $hold["reserveId"];
                $hold['statusCode'] = isset($hold["actions"]["checkout"]) ? "i" : "-";
                $hold['frozen'] = isset($hold["holdSuspension"]);

                $sierraHolds[] = $hold;
            }
        }

        $this->sessionCache->holds = $sierraHolds;
        if( isset($this->sessionCache->staleHoldsHash) ) {
            if( md5(json_encode($sierraHolds)) != $this->sessionCache->staleHoldsHash ) {
                unset( $this->sessionCache->staleHoldsHash );
            }
        }
        return $this->sessionCache->holds;
    }

    /**
     * Get Cancel Hold Details
     *
     * Get required data for canceling a hold. This value is used by relayed to the
     * cancelHolds function when the user attempts to cancel a hold.
     *
     * @param array $holdDetails An array of hold data
     *
     * @return string Data for use in a form field
     */
    public function getCancelHoldDetails($holdDetails)
    {
        return $holdDetails['requestId'] ?? '';
    }

    /**
     * Cancel Holds
     *
     * Attempts to Cancel a hold. The data in $cancelDetails['details'] is determined
     * by getCancelHoldDetails().
     *
     * @param array $cancelDetails An array of item and patron data
     *
     * @return array               An array of data on each request including
     * whether or not it was successful and a system message (if available)
     */
    public function cancelHolds($cancelDetails)
    {
        // invalidate the cached data
        $this->sessionCache->staleHoldsHash = md5(json_encode($this->sessionCache->holds));

        $results = ['count' => 0, 'items' => []];
        $overDriveHolds = [];
        for($i=0; $i<count($cancelDetails["details"]); $i++ )
        {
            if( substr($cancelDetails["details"][$i], 0, 9) == "OverDrive" ) {
                $overDriveHolds[] = substr(array_splice($cancelDetails["details"], $i, 1)[0], 9);
                $i--;
            }
        }

        // grab a copy of this because the OverDrive functionality can wipe it
        $cachedHolds = $this->sessionCache->holds;

        // process the overdrive holds
        foreach($overDriveHolds as $overDriveID ) {
            $overDriveResults = $this->connector->cancelHold($overDriveID);
            $results['count']++;
            $results['items'][$overDriveID] = ['item_id' => $overDriveID,
                                               'success' => $overDriveResults->status,
                                               'status' => $overDriveResults->status ? 'hold_cancel_success' : 'hold_cancel_fail',
                                               'sysMessage' => $overDriveResults->status ? null : $this->formatErrorMessage($overDriveResults->msg)];
        }

        // process the sierra holds
        if( count($cancelDetails["details"]) > 0 ) {
            $sierraResults = parent::cancelHolds($cancelDetails);
            $results['count'] += $sierraResults['count'];
            $results['items'] = array_merge($results['items'], $sierraResults['items']);
        }

        return $results;
    }

    /**
     * Freeze Holds
     *
     * This is responsible for (un)freezing a patron's holds.
     *
     * @param array  $holds  The holds to freeze
     *
     * @throws ILSException
     * @return mixed          Associative array of patron info on successful login,
     * null on unsuccessful login.
     */
    public function freezeHolds($holds, $doFreeze){
        // invalidate the cached data
        $this->sessionCache->staleHoldsHash = md5(json_encode($this->sessionCache->holds));

        $success = true;
        $overDriveHolds = [];
        for($i=0; $i<count($holds["details"]); $i++ )
        {
            if( substr($holds["details"][$i], 0, 9) == "OverDrive" ) {
                $overDriveHolds[] = substr(array_splice($holds["details"], $i, 1)[0], 9);
                $i--;
            }
        }

        // grab a copy of this because the OverDrive functionality can wipe it
        $cachedHolds = $this->sessionCache->holds;

        // process the overdrive holds
        foreach($overDriveHolds as $overDriveID ) {
            $overDriveResults = $this->connector->freezeHold($overDriveID, $doFreeze);
            $success &= $overDriveResults->status;
        }

        // process the sierra holds
        foreach( $holds["details"] ?? [] as $thisHold ) {
            $result = $this->makeRequest(
                ['v5', 'patrons', 'holds', $thisHold], json_encode(['freeze' => $doFreeze]), 'PUT', $holds["patron"]
            );
            $success &= empty($result['code']);
        }

        return ["success" => $success];
    }

    public function getNumberOfHoldsOnRecord($id) {
        if( $this->memcached->get("numberOfHoldsOnID" . $id) !== null ) {
            $holdQueueLength = $this->getBibRecord($id, "holdCount");
            $this->memcached->set("numberOfHoldsOnID" . $id, $holdQueueLength["holdCount"] ?? 0, 900);
        }
        return $this->memcached->get("numberOfHoldsOnID" . $id);
    }

    /**
     * Get Pick Up Locations
     *
     * This is responsible for getting a list of valid library locations for
     * holds / recall retrieval
     *
     * @param array $patron   Patron information returned by the patronLogin method.
     * @param array $holdInfo Optional array, only passed in when getting a list
     * in the context of placing a hold; contains most of the same values passed to
     * placeHold, minus the patron data.  May be used to limit the pickup options
     * or may be ignored.  The driver must not add new options to the return array
     * based on this data or other areas of VuFind may behave incorrectly.
     *
     * @throws ILSException
     * @return array        An array of associative arrays with locationID and
     * locationDisplay keys
     */
    public function getPickUpLocations($patron = false, $holdInfo = null)
    {
        if( $this->memcached->get("pickup_locations") ) {
            return $this->memcached->get("pickup_locations");
        }

        $locations = $this->getDbTable('Location')->getPickupLocations();
        $pickupLocations = [];
        foreach( $locations as $loc ) {
            $pickupLocations[] = ["locationID" => $loc->code, "locationDisplay" => $loc->displayName];
        }
        $this->memcached->set("pickup_locations", $pickupLocations);

        return $pickupLocations;
    }


    /**
     * Place Hold
     *
     * Attempts to place a hold or recall on a particular item and returns
     * an array with result details or throws an exception on failure of support
     * classes
     *
     * @param array $holdDetails An array of item and patron data
     *
     * @throws ILSException
     * @return mixed An array of data on the request including
     * whether or not it was successful and a system message (if available)
     */
    public function placeHold($holdDetails)
    {
        // see whether or not it's an overdrive hold
        if( $holdDetails['overDriveId'] ?? false ) {
            return $this->connector->placeOverDriveHold($holdDetails['overDriveId']);
        }

        // sanitize the ids if necessary
        if( substr($holdDetails["id"], 0, 2) == ".b" ) {
            if( !isset($holdDetails["bibId"]) ) {
                $holdDetails["bibId"] = $holdDetails["id"];
            }
            $holdDetails["id"] = substr($holdDetails["id"], 2, -1);
        }
        if( substr($holdDetails["item_id"] ?? "", 0, 2) == ".i" ) {
            $holdDetails["item_id"] = substr($holdDetails["item_id"], 2, -1);
        }

        // invalidate the cached data
        $this->sessionCache->staleHoldsHash = md5(json_encode($this->sessionCache->holds));

        // item level holds via the API don't work yet
        // BJP - neither do local copy overriding the hold
        if( true || isset($holdDetails["item_id"]) ) {
            $holdsInfo = $this->placeItemLevelHold($holdDetails);
        } else {
            $holdsInfo = parent::placeHold($holdDetails);
        }

        // if they successfully placed the hold, check to see whether this item is in their book cart. If so, remove it.
        if( $holdsInfo['success'] ) {
            $this->removeFromBookCart([isset($holdDetails['bibId']) ? $holdDetails['bibId'] : $holdDetails['id']]);
        }
        return $holdsInfo;
    }

    /**
     * Update Holds
     *
     * Attempts to update the pickup location for an array of holds and returns
     * an array with result details or throws an exception on failure of support
     * classes
     *
     * @param array $holds The holds to update and the location to change them to
     *
     * @throws ILSException
     * @return mixed An array of data on the request including
     * whether or not it was successful and a system message (if available)
     */
    public function updateHolds($holds)
    {
        // invalidate the cached data
        $this->sessionCache->staleHoldsHash = md5(json_encode($this->sessionCache->holds));

        // pull out overdrive holds, since we're updating their email
        $success = true;
        $overDriveHolds = [];
        for($i=0; $i<count($holds["details"]); $i++ )
        {
            if( substr($holds["details"][$i], 0, 9) == "OverDrive" ) {
                $overDriveHolds[] = substr(array_splice($holds["details"], $i, 1)[0], 9);
                $i--;
            }
        }

        // grab a copy of this because the OverDrive functionality can wipe it
        $cachedHolds = $this->sessionCache->holds;

        // process the overdrive holds
        foreach($overDriveHolds as $overDriveID ) {
            $overDriveResults = $this->connector->updateHold($overDriveID, $holds["newEmail"]);
            $success &= $overDriveResults->status;
        }

        // compare the sierra holds to my list of holds (workaround for item-level stuff)
        if( count($holds["details"]) > 0 ) {
            foreach( $holds["details"] as $key => $thisUpdateId ) {
                foreach( $cachedHolds as $thisHold ) {
                    if( false && $thisHold["requestId"] == $thisUpdateId && $thisHold["item_id"] != $thisUpdateId ) {
                        $success &= $this->updateHoldDetailed($holds["patron"], "requestId", "patronId", "update", "title", $thisHold["item_id"], $holds["newLocation"]);
                        unset($holds["details"][$key]);
                    }
                }
            }
        }

        // process the sierra holds
        $success = true;
        foreach( $holds["details"] ?? [] as $thisHold ) {
            $result = $this->makeRequest(
                ['v5', 'patrons', 'holds', $thisHold], json_encode(['pickupLocation' => $holds["newLocation"]]), 'PUT', $holds["patron"]
            );
            $success &= empty($result['code']);
        }

        return ["success" => $success];
    }

    /**
     * Get notifications
     *
     * This is responsible for grabbing a few static notifications based on a patron's profile information.
     *
     * @param array  $profile  The patron's info
     *
     * @return array           Associative array of notifications
     */
    public function getNotifications($profile){
        $notifications = [];
        if( $profile["moneyOwed"] > 0 ) {
            // build the message
            $msg = "<form name=\"creditForm\" method=\"post\" onsubmit=\"return checkFees()\" target=\"_blank\" action=\"https://payflowlink.paypal.com\" data-lightbox-ignore>" .
                   "<input type=\"hidden\" name=\"action\" value=\"confirmInfo\">" .
                   "<input type=\"hidden\" name=\"key\" value=\"-3994241445885651921\">" .
                   "<input type=\"hidden\" name=\"linkMode\" value=\"true\">" .
                   "<input type=\"hidden\" name=\"payAmount\" value=\"200\">" .
                   "<input type=\"hidden\" name=\"minFeeMsg\" value=\"Please visit the library to pay this amount\">" .
                   "<input type=\"hidden\" name=\"partner\" value=\"PayPal\">" .
                   "<input type=\"hidden\" name=\"type\" value=\"S\">" .
                   "<input type=\"hidden\" name=\"orderForm\" value=\"TRUE\">" .
                   "<input type=\"hidden\" name=\"echoData\" value=\"TRUE\">" .
                   "<input type=\"hidden\" name=\"showConfirm\" value=\"TRUE\">" .
                   "<input type=\"hidden\" name=\"method\" value=\"CC\">" .
                   "<input type=\"hidden\" name=\"login\" value=\"einetworklink\">" .
                   "<input type=\"hidden\" name=\"custId\" value=\"" . $profile["id"] . "\">" .
                   "<input type=\"hidden\" name=\"description\" value=\"\">" .
                   "<input type=\"hidden\" name=\"emailCustomer\" value=\"TRUE\">" .
                   "<input type=\"hidden\" name=\"address\" value=\"\">" .
                   "<input type=\"hidden\" name=\"city\" value=\"\">" .
                   "<input type=\"hidden\" name=\"state\" value=\"\">" .
                   "<input type=\"hidden\" name=\"zip\" value=\"\">" .
                   "<input type=\"hidden\" name=\"phone\" value=\"\">" .
                   "<input type=\"hidden\" name=\"email\" value=\"\">" .
                   "<input type=\"hidden\" name=\"name\" value=\"\">" .
                   "<input type=\"hidden\" name=\"user2\" value=\"\">" .
                   "<input type=\"hidden\" name=\"user3\" value=\"\">" .
                   "<input type=\"hidden\" name=\"user4\" value=\"\">" .
                   "<input type=\"hidden\" name=\"user5\" value=\"\">" .
                   "<input type=\"hidden\" name=\"user6\" value=\"\">" .
                   "<input type=\"hidden\" name=\"user7\" value=\"\">" .
                   "<input type=\"hidden\" name=\"user8\" value=\"\">" .
                   "<input type=\"hidden\" name=\"user9\" value=\"\">" .
                   "<input type=\"hidden\" name=\"user10\" value=\"ecom\">" .
                   "<input type=\"hidden\" name=\"comment1\" value=\"f\">" .
                   "<input type=\"hidden\" name=\"comment2\" value=\"p" . $profile["id"] . "\">" .
                   "<input type=\"hidden\" name=\"parsedMoneyfmt\" value=\",.2\" id=\"moneyfmt\">" .
                   "<input type=\"hidden\" name=\"currencySymbol\" value=\"$\" id=\"currencySymbol\">" .
                   "<input type=\"hidden\" name=\"serviceCharge\" value=\"0\" id=\"serviceCharge\"><table style=\"border-collapse:separate;border-spacing:0 1em\">";
            $user1 = "";
            $total = 0;

            $fines = $this->getMyFines($this->sessionCache->patronLogin);
            foreach($fines as $i => $thisFine) {
                //$adjustedValue = $thisFine->itemCharge + $thisFine->processingFee + $thisFine->billingFee - $thisFine->amountPaid;
                $msg .= "<tr><td style=\"padding:5px\"><input type=\"checkbox\" name=\"selectedFees\" value=\"" . $thisFine["balance"] . "\" checked=\"checked\" onclick=\"checkFees()\" id=\"" . $thisFine["invoice"] . "\">" .
                        "</td><td style=\"padding:5px\">" . sprintf("$%.2f", $thisFine["balance"] * 0.01) . "</td><td style=\"padding:5px;line-height:1.23em\">";
                if( $thisFine["title"] && $thisFine["type"] == "Overdue" ) {
                    $msg .= "<div class=\"bold\">Overdue Item Returned</div><div style=\"margin-left:20px;text-indent:-20px\">" . str_replace("'", "\'", $thisFine["title"]) . "</div>" .
                            "<div><span class=\"bold\">Date Assessed:</span> " . strftime("%a %b %e, %Y", strtotime($thisFine["createdate"])) . "</div>";
                } else if( $thisFine["title"] && $thisFine["type"] == "Overdue Renewal" ) {
                    $msg .= "<div class=\"bold\">Overdue Item Renewed</div><div style=\"margin-left:20px;text-indent:-20px\">" . str_replace("'", "\'", $thisFine["title"]) . "</div>" .
                            "<div><span class=\"bold\">Date Assessed:</span> " . $thisFine["createdate"] . "</div>";
                } else if( $thisFine["description"] && $thisFine["type"] == "Manual" ) {
                    $msg .= "<div class=\"bold\">Manually added fine</div><div style=\"margin-left:20px;text-indent:-20px\">" . str_replace("'", "\'", $thisFine["description"]) . "</div>";
                } else {
                    $msg .= "<div class=\"bold\">" . $thisFine["type"] . "</div><div style=\"margin-left:20px;text-indent:-20px\">" .
                            ($thisFine["title"] ? str_replace("'", "\'", $thisFine["title"]) : str_replace("'", "\'", $thisFine["description"])) . "</div>";
                }
                $msg .= "</td></tr>";
                $user1 .= $thisFine["invoice"] . ":";
                $total += $thisFine["balance"];
            }

            $msg .= "</table><input type=\"hidden\" name=\"amount\" value=\"" . sprintf("%.2f", $total * 0.01) . "\">" .
                    "<input type=\"hidden\" name=\"user1\" value=\"" . $user1 . "\"><div class=\"center\"><div id=\"minimumPayment\" style=\"color:#f00;font-weight:700\">For payments less than $2.00, please see library staff.</div><br><span class=\"bold\">Total Selected:</span><span id=\"finesTotal\">" . sprintf("%.2f", $total * 0.01) . "</span>" .
                    "<button class=\"btn-default btn-wide\" id=\"paypalButton\" style=\"margin:15px;cursor:default\">Pay Online</button></div><div>Clicking this button will take you to Paypal's secure server to enter your payment info.</div>" .
                    "</form><script type=\"text/javascript\">function checkFees() { var total = 0; var user1 = \"\";" .
                    " $('input[name=selectedFees]').each( function() { total += $(this).is(\":checked\") ? parseInt($(this).attr(\"value\")) : 0; user1 += $(this).is(\":checked\") ? ($(this).attr(\"id\") + \":\") : \"\" } ); " .
                    "$(\"input[name=amount]\").attr(\"value\", total * 0.01); $(\"#finesTotal\").html(\"$\" + (total * 0.01).toFixed(2)); $(\"input[name=user1]\").attr(\"value\", user1); if( total >= parseInt($('input[name=payAmount]').attr(\"value\")) ) { " .
                    "$('#paypalButton').prop(\"disabled\", false); $('#minimumPayment').css(\"display\", \"none\"); } else " .
                    "{ $('#paypalButton').prop(\"disabled\", true); $('#minimumPayment').css(\"display\", \"initial\"); } } setTimeout(checkFees, 10)</script>";

            // Echo the result
            if( $total > 0 ) {
                $notifications[] = ["subject" => "<span class=\"messageWarning\">You have fines.</span>",
                                    "message" => $msg,
                                    "extra" => " (Total: $" . number_format($profile["moneyOwed"],2) . ") Click here for details and to pay."];
            } else {
                $profile["moneyOwed"] = 0;
            }
        }
        if( isset($profile["showTemporaryClosureMessage"]) && $profile["showTemporaryClosureMessage"] ) {
            $notifications[] = ["attnSubject" => "<span class=\"messageWarning\">Temporary library closure.</span> Click here to learn more.",
                                "subject" => "Temporary library closure",
                                "message" => "Your home library or one of your preferred libraries is temporarily closed. It will not show up as an option for picking up your requests until it has reopened, and it will not be an option " .
                                             "on the Preferred Libraries section of the <a class=\"messageLink\" href=\"/MyResearch/Profile\" data-lightbox-ignore>profile page</a>. In the meantime, you can choose a different library location as a preferred " .
                                             "library there. If you would rather not change it, you can simply wait until that location reopens and it will once again appear in your preferred libraries."];
        }
        if( ($profile["preferredlibrarycode"] == null || $profile["preferredlibrarycode"] == "none") && ($profile["alternatelibrarycode"] == null || $profile["alternatelibrarycode"] == "none") ) {
            $notifications[] = ["attnSubject" => "<span class=\"messageWarning\">Please choose a preferred or alternate library.</span> Click here to learn how.",
                                "subject" => "Choose a preferred or alternate library",
                                "message" => "You have not yet chosen a preferred or alternate library. Doing so will make placing requests on physical items much easier, since your preferred libraries are used as the default pickup " .
                                             "location. You can assign a preferred or alternate library on the <a class=\"messageLink\" href=\"/MyResearch/Profile\" data-lightbox-ignore>profile page</a>."];
        }
        if( date_diff(date_create_from_format("m-d-Y", $profile["expiration_date"]), date_create(date("Y-m-d")))->invert == 0 ) {
            $notifications[] = ["subject" => "<span class=\"messageWarning\">Card expired</span>",
                                "message" => "Your library card is expired. Please visit your local library to renew your card to ensure access to all online services."];
        } else if( date_diff(date_create_from_format("m-d-Y", $profile["expiration_date"]), date_create(date("Y-m-d")))->days <= 30 ) {
            $notifications[] = ["subject" => "Card expiration approaching",
                                "message" => "Your library card is due to expire within the next 30 days. Please visit your local library to renew your card to ensure access to all online services."];
        }
        return $notifications;
    }

    /**
     * Get announcements
     *
     * This is responsible for grabbing system-wide announcements that haven't been dismissed by the user.
     *
     * @param string  $ns      The namespace of the desired announcements
     *
     * @return array           Associative array of announcements
     */
    public function getAnnouncements($ns=null){
        $announcements = [];
        if( isset($this->config['Site']['announcement']) ) {
            foreach($this->config['Site']['announcement'] as $news) {
                $hash = md5($news);
                // see if we need to unblock this
                if( !$this->sessionCache->patronLogin && isset($this->sessionCache->dismissedAnnouncements[$hash]) && ($this->sessionCache->dismissedAnnouncements[$hash] + 300) < time() ) {
                    unset($this->sessionCache->dismissedAnnouncements[$hash]);
                }
                // add it to the array if they haven't dismissed it
                if( !isset($this->sessionCache->dismissedAnnouncements[$hash]) ) {
                    $announcements[] = ['html' => true, 'msg' => $news, 'announceHash' => $hash];
                }
            }
        }
        return $announcements;
    }

    /**
     * Dismiss announcement
     *
     * This is responsible for dismissing a system-wide announcement until the user changes.
     *
     * @param string  $hash    The hash of the desired announcement
     */
    public function dismissAnnouncement($hash){
        if( !isset($this->sessionCache->dismissedAnnouncements) ) {
            $this->sessionCache->dismissedAnnouncements = [];
        }
        $this->sessionCache->dismissedAnnouncements[$hash] = time();
    }

    /**
     * Get status for an item
     *
     * @param array $item Item from Sierra
     *
     * @return array Status string, possible due date and any notes
     */
    protected function getItemStatus($item)
    {
        $duedate = '';
        $notes = [];
        $statusCode = trim($item['status']['code']);
        if (isset($this->itemStatusMappings[$statusCode])) {
            $status = $this->itemStatusMappings[$statusCode];
        } else {
            $status = isset($item['status']['display'])
                ? ($item['status']['display'])
                : '-';
        }
        $status = trim($status);

        // For some reason at least API v2.0 returns "ON SHELF" even when the
        // item is out. Use duedate to check if it's actually checked out.
        if (isset($item['status']['duedate'])) {
            $duedate = $this->dateConverter->convertToDisplayDate(
                \DateTime::ISO8601,
                $item['status']['duedate']
            );
            $status = 'CHECKED OUT';
        } else {
            switch ($status) {
            case '-':
                $status = 'AVAILABLE';
                break;
            case 'o':
            case 'Lib Use Only':
                $status = 'NONCIRCULATING';
                break;
            }
        }
        if ($status == 'AVAILABLE') {
            // Check for checkin date
            $today = $this->dateConverter->convertToDisplayDate('U', time());
            if (isset($item['fixedFields']['68'])) {
                $checkedIn = $this->dateConverter->convertToDisplayDate(
                    \DateTime::ISO8601, $item['fixedFields']['68']['value']
                );
                if ($checkedIn == $today) {
                    $notes[] = $this->translate('Returned today');
                }
            }
        }
        return [$status, $duedate, $notes];
    }

    /**
     * Get Item Statuses
     *
     * This is responsible for retrieving the status information of a certain
     * record.
     *
     * @param string $id The record id to retrieve the holdings for
     *
     * @return array An associative array with the following keys:
     * id, availability (boolean), status, location, reserve, callnumber.
     */
    protected function getItemStatusesForBib($id)
    {
        // sanitize the id if necessary
        if( substr($id, 0, 2) == ".b" ) {
            $id = substr($id, 2, -1);
        }

        $results = parent::getItemStatusesForBib($id);

        // add in the status code (and check if anybody needs an item-level link)
        $addAllLinks = false;
        foreach( $results as $hKey => $thisHolding ) {
            $thisHolding["statusCode"] = $this->itemStatusReverseMappings[$thisHolding["status"]];
            if( !$thisHolding["availability"] && in_array($thisHolding["statusCode"], ["-","o","p","v","y"]) && !$thisHolding["duedate"] ) {
                $thisHolding["availability"] = true;
            }
            if( !isset($thisHolding["copiesOwned"]) ) {
                $thisHolding["copiesOwned"] = 1;
            }
            $results[$hKey] = $thisHolding;

            $addAllLinks |= $thisHolding["addLink"] ?? false;
        }
        // if one guy gets a item-level link, they all need one
        if( $addAllLinks ) {
            foreach( $results as $hKey => $thisHolding ) {
                $thisHolding['addLink'] = true;
                $thisHolding['is_holdable'] = true;
                $thisHolding['level'] = 'copy';
                $results[$hKey] = $thisHolding;
            }
        }

        return $results;
    }

    /**
     * Convenience function to test whether a given Solr ID value corresponds to an OverDrive item
     *
     * @param  string $id a Solr ID value
     *
     * @return mixed  OverDrive ID if the Solr ID maps to an OverDrive item, false if not
     */
    public function getOverDriveID($id) {
        // see if it's there
        if( !$this->memcached->get("overdriveID" . $id) ) {
            // grab a bit more information from Solr
            $solrBaseURL = $this->config['Solr']['url'];
            $curl_url = $solrBaseURL . "/biblio/select?q=*%3A*&fq=id%3A%22" . $id . "%22&fl=econtent_source,externalId&wt=csv";
            $curl_connection = curl_init($curl_url);
            curl_setopt($curl_connection, CURLOPT_CONNECTTIMEOUT, 30);
            curl_setopt($curl_connection, CURLOPT_USERAGENT,"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
            curl_setopt($curl_connection, CURLOPT_RETURNTRANSFER, true);
            $sresult = curl_exec($curl_connection);
            $values = explode("\n", $sresult);

            // is it an OverDrive item?
            if( count($values) > 1 && explode(",", $values[1])[0] == "OverDrive" ) {
                $this->memcached->set("overdriveID" . $id, explode(",", $values[1])[1]);
            }
        }

        // send it back
        return $this->memcached->get("overdriveID" . $id);
    }

    /**
     * Convenience function to get the Solr Record corresponding to a given externalId
     *
     * @param  string $id an externalId value
     *
     * @return mixed  A Solr record if the externalId maps to a Solr item, false if not
     */
    public function getSolrRecordFromExternalId($id) {
        if( $this->memcached->get("solrRecordForID" . $id) ) {
            return $this->memcached->get("solrRecordForID" . $id);
        }
        // grab a bit more information from Solr
        $solrBaseURL = $this->config['Solr']['url'];
        $curl_url = $solrBaseURL . "/biblio/select?q=*%3A*&fq=externalId%3A%22" . strtolower($id) . "%22&wt=csv&csv.separator=%07&csv.encapsulator=%15";
        $curl_connection = curl_init($curl_url);
        curl_setopt($curl_connection, CURLOPT_CONNECTTIMEOUT, 30);
        curl_setopt($curl_connection, CURLOPT_USERAGENT,"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
        curl_setopt($curl_connection, CURLOPT_RETURNTRANSFER, true);
        $sresult = curl_exec($curl_connection);
        $values = explode("\n", $sresult);
        // sometimes OverDrive wants to break our system by stashing bonus \n characters in there. this puts them back together.
        while( count($values) > 3 ) {
            array_splice($values, 1, 2, $values[1] . "\n" . $values[2]);
        }
        // is it a Solr item?
        if( count($values) > 2 ) {
            $item = array();
            $fieldNames = explode(chr(7), $values[0]);
            // we have to do some hocus pocus here since the values can also include the delimiter if they are multi-valued
            $fieldValues = explode(chr(7), $values[1]);
            for($i=0;$i<count($fieldValues);$i++) {
                while( substr($fieldValues[$i], 0, 1) == chr(21) && substr($fieldValues[$i], -1) != chr(21) ) {
                    array_splice($fieldValues, $i, 2, $fieldValues[$i] . "\," . $fieldValues[$i+1]);
                }
                if( substr($fieldValues[$i], 0, 1) == chr(21) ) {
                    $fieldValues[$i] = substr($fieldValues[$i], 1, -1);
                }
            }
            for($i=0; $i<count($fieldNames); $i++) {
                $item[$fieldNames[$i]] = $fieldValues[$i];
            }
            $this->memcached->set("solrRecordForID" . $id, $item);
            return $this->memcached->get("solrRecordForID" . $id);
        }
        // not in Solr
        return false;
    }

    /**
     * Remove from book cart
     *
     * This removes the given bib from the logged in user's book cart.
     *
     * @param string  $id    The record id to remove from the book cart
     */
    public function removeFromBookCart($id) {
        if( !isset($this->sessionCache->patron) ) {
            return;
        }
        // get the bookcart
        $user = $this->getDbTable('User')->getByCatUsername($this->sessionCache->patron["cat_username"]);
        $bookCart = $user->getBookCart();
        // remove this item from it
        $bookCart->removeResourcesById($user, [$id]);
        // clear the cached contents of the list
        $this->clearMemcachedVar("cachedList" . $bookCart->id);
    }

    /**
     * Test Serial
     *
     * This checks the API to see if this bib has a serial type.
     *
     * @param string $id The record id to test the bibLevel
     *
     * @return bool  Whether or not this bib is a serial type (used to determine if we need to look for checkin records)
     */
    public function isSerial($id)
    {
        // grab a bit more information from Solr
        $solrBaseURL = $this->config['Solr']['url'];
        $curl_url = $solrBaseURL . "/biblio/select?q=*%3A*&fq=id%3A%22" . strtolower($id) . "%22&fl=bib_level&wt=csv";
        $curl_connection = curl_init($curl_url);
        curl_setopt($curl_connection, CURLOPT_CONNECTTIMEOUT, 30);
        curl_setopt($curl_connection, CURLOPT_USERAGENT,"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
        curl_setopt($curl_connection, CURLOPT_RETURNTRANSFER, true);
        $sresult = curl_exec($curl_connection);
        $values = explode("\n", $sresult);

        // is it a Solr item?
        return (count($values) > 2) && ($values[1] == "s");
    }

    /**
     * Translate location name
     *
     * @param array $location Location
     *
     * @return string
     */
    protected function translateLocation($location)
    {
        return $location['code'];
    }

    /**
     * Check if an item is holdable
     *
     * @param array $item Item from Sierra
     * @param array $bib  Bib record from Sierra
     *
     * @return bool
     */
    protected function itemHoldAllowed($item, $bib)
    {
        // if this item has volume info, we're allowed to place a hold on it
        foreach( ($item["varFields"] ?? []) as $thisVarField ) {
            if( ($thisVarField["fieldTag"] ?? "") == "v" && isset($thisVarField["content"]) ) {
                return true;
            }
        }
        return parent::itemHoldAllowed($item, $bib);
    }

    /**
     * Fetch a bib record from Sierra
     *
     * @param int    $id     Bib record id
     * @param string $fields Fields to request
     * @param array  $patron Patron information, if available
     *
     * @return array|null
     */
    protected function getBibRecord($id, $fields, $patron = false)
    {
        // sanitize the id if necessary
        if( substr($id, 0, 2) == ".b" ) {
            $id = substr($id, 2, -1);
        }

        return parent::getBibRecord($id, $fields, $patron);
    }

    /**
     * Utility method to calculate a check digit for a given id.
     *
     * @param string $id       Record ID
     *
     * @return character
     */
    public function getCheckDigit($id)
    {
        // pull off the item type if they included it
        if( !is_numeric($id) ) {
            $id = substr($id, 1);
        }
        // make sure it's a number
        if( !is_numeric($id) ) {
            return null;
        }
        // calculate it
        $checkDigit = 0;
        $multiple = 2;
        while( $id > 0 ) {
            $digit = $id % 10;
            $checkDigit += $multiple * $digit;
            $id = ($id - $digit) / 10;
            $multiple++;
        }
        $checkDigit = $checkDigit % 11;
        return ($checkDigit == 10) ? "x" : $checkDigit;
    }

    /**
     * Make Request
     *
     * Makes a request to the Sierra REST API
     *
     * @param array  $hierarchy Array of values to embed in the URL path of
     * the request
     * @param array  $params    A keyed array of query data
     * @param string $method    The http request method to use (Default is GET)
     * @param array  $patron    Patron information, if available
     *
     * @throws ILSException
     * @return mixed JSON response decoded to an associative array or null on
     * authentication error
     */
    protected function makeRequest($hierarchy, $params = false, $method = 'GET',
        $patron = false
    ) {
        $hash = md5(json_encode($hierarchy) . ($params ? ("###" . json_encode($params)) : ""));
        if( !$this->memcached->get($hash) || in_array("token", $hierarchy) ) {
            $result = parent::makeRequest($hierarchy, $params, $method, $patron);

            $this->memcached->set($hash, json_encode($result), 30);
        }

        return json_decode($this->memcached->get($hash), true);
    }


    /**
     * Renew the API access token and store it in the cache.
     * Throw an exception if there is an error.
     *
     * @param array $patron Patron information, if available
     *
     * @return bool True on success, false on patron login failure
     * @throws ILSException
     */
    protected function renewAccessToken($patron = false)
    {
        // force the renewal if requested
        if( $patron === true ) {
            $this->memcached->delete("sharedAccessToken");
            $patron = false;
        }

        if( $sharedToken = $this->memcached->get("sharedAccessToken") ) {
            $this->sessionCache->accessToken = $sharedToken;
            return true;
        } else if( parent::renewAccessToken($patron) ) {
            $this->memcached->set("sharedAccessToken", $this->sessionCache->accessToken, 3600);
            return true;
        }
        return false;
    }

    /**
     * Convenience function to get the reading history info for a set of Solr IDs
     *
     * @param  array $id a set of Solr ID values
     *
     * @return array map of the IDs to author, title, and format
     */
    protected function getReadingHistoryInfo($ids) {
        $returnMap = [];

        // weed out any we've already seen
        foreach( $ids as $thisKey => $thisID ) {
            if( $thisInfo = $this->memcached->get("readingHistoryInfo" . $thisID) ) {
                $returnMap[$thisID] = $thisInfo;
                unset($ids[$thisKey]);
            }
        }

        // see if it's there
        if( count($ids) ) {
            // grab a bit more information from Solr
            $solrBaseURL = $this->config['Solr']['url'];
            $curl_url = $solrBaseURL . "/biblio/select?q=*%3A*&fq=";
            $addOr = false;
            foreach( $ids as $thisID ) {
                $curl_url .= ($addOr ? "%20OR%20" : "") . "id%3A%22" . $thisID . "%22";
                $addOr = true;
            }
            $curl_url .= "&fl=id,author,title,format&wt=csv&csv.separator=%07&csv.encapsulator=%15&rows=50";
            $curl_connection = curl_init($curl_url);
            curl_setopt($curl_connection, CURLOPT_CONNECTTIMEOUT, 30);
            curl_setopt($curl_connection, CURLOPT_USERAGENT,"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
            curl_setopt($curl_connection, CURLOPT_RETURNTRANSFER, true);
            $sresult = curl_exec($curl_connection);
            $values = explode("\n", $sresult);

            // parse this
            $fieldMap = [];
            foreach( $values as $index => $thisLine ) {
                $pieces = explode(chr(7), $thisLine);
                if( !$thisLine ) {
                    continue;
                }
                if( $index == 0 ) {
                    $fieldMap = array_flip($pieces);
                    continue;
                }

                // we have to do some hocus pocus here since the values can also include the delimiter if they are multi-valued
                for($i=0;$i<count($pieces);$i++) {
                    while( substr($pieces[$i], 0, 1) == chr(21) && substr($pieces[$i], -1) != chr(21) ) {
                        array_splice($pieces, $i, 2, $pieces[$i] . "\," . $pieces[$i+1]);
                    }
                    if( substr($pieces[$i], 0, 1) == chr(21) ) {
                        $pieces[$i] = substr($pieces[$i], 1, -1);
                    }
                }

                $isILL = (substr($pieces[$fieldMap["title"]], 0 , 17) == "InterLibrary Loan") && (intval(substr($pieces[$fieldMap["title"]], 17)) > 0);
                $newInfo = ["author" => $pieces[$fieldMap["author"]], "title" => $pieces[$fieldMap["title"]], "format" => $pieces[$fieldMap["format"]], "ILL" => $isILL];
                $this->memcached->set("readingHistoryInfo" . $pieces[$fieldMap["id"]], $newInfo);
                $returnMap[$pieces[$fieldMap["id"]]] = $newInfo;
            }
        }

        // send it back
        return $returnMap;
    }

    public function getReadingHistory($patron, $sortOption = "outDate") {
        $this->testSession();

        // if it isn't cached yet, grab it
        if( !isset($this->sessionCache->readingHistory) ) {
            $readingHistoryTitles = isset($this->sessionCache->readingHistoryPartial) ? $this->sessionCache->readingHistoryPartial : [];
            $enabled = true;
            $done = false;

            $result = $this->makeRequest(
                ['v' . $this->apiVersion, 'patrons', $patron["id"], 'checkouts', 'history'], ['limit' => 50, 'offset' => count($readingHistoryTitles)], 'GET', $patron
            );

            if( (($result["httpStatus"] ?? 200) == 400) && (($result["code"] ?? 0) == 146) ) {
                $enabled = false;
            }

            // fetch it by pages of 50
            while( $enabled && count($readingHistoryTitles) < $result["total"] ) {
                // grab the author and title
                $ids = [];
                foreach( $result["entries"] as $index => $thisEntry ) {
                    $rsh = substr($thisEntry["id"], strrpos($thisEntry["id"], "/") + 1);
                    $bibID = substr($thisEntry["bib"], strrpos($thisEntry["bib"], "/") + 1);
                    $bibID = ".b" . $bibID . $this->getCheckDigit($bibID);
                    $result["entries"][$index]["rsh"] = $rsh;
                    $result["entries"][$index]["bibID"] = $bibID;
                    $result["entries"][$index]["checkout"] = strftime("%m/%d/%y", strtotime($thisEntry["outDate"]));
                    if( substr($result["entries"][$index]["checkout"], 3, 1) == "0" ) {
                        $result["entries"][$index]["checkout"] = substr($result["entries"][$index]["checkout"], 0, 3) . substr($result["entries"][$index]["checkout"], 4);
                    }
                    if( substr($result["entries"][$index]["checkout"], 0, 1) == "0" ) {
                        $result["entries"][$index]["checkout"] = substr($result["entries"][$index]["checkout"], 1);
                    }
                    $ids[] = $bibID;
                }
                $extraInfo = $this->getReadingHistoryInfo($ids);
                foreach( $result["entries"] as $index => $thisEntry ) {
                    if( isset($extraInfo[$thisEntry["bibID"]]) ) {
                        $result["entries"][$index]["author"] = $extraInfo[$thisEntry["bibID"]]["author"];
                        $result["entries"][$index]["title"] = $extraInfo[$thisEntry["bibID"]]["title"];
                        $result["entries"][$index]["format"] = $extraInfo[$thisEntry["bibID"]]["format"];
                        if( $extraInfo[$thisEntry["bibID"]]["ILL"] ?? false ) {
                            $result["entries"][$index]["title"] = "InterLibrary Loan";
                            $result["entries"][$index]["skipLoad"] = true;
                        }
                    } else {
                        $result["entries"][$index]["title"] = "Title no longer available";
                        $result["entries"][$index]["skipLoad"] = true;
                    }
                }

                // merge this info in
                $readingHistoryTitles = array_merge($readingHistoryTitles, $result["entries"]);
                $this->sessionCache->readingHistoryPartial = $readingHistoryTitles;

                // grab the next page
                $result = $this->makeRequest(
                    ['v5', 'patrons', $patron["id"], 'checkouts', 'history'], ['limit' => 50, 'offset' => count($readingHistoryTitles)], 'GET', $patron
                );
            }

            $this->sessionCache->readingHistory = $enabled ? $readingHistoryTitles : false;
        }
        $readingHistory = $this->sessionCache->readingHistory;

        // do the desired sort
        $sortedTitles = [];
        if( $readingHistory !== false ) {
            foreach( $readingHistory as $thisEntry ) {
                $sortKey = (isset($thisEntry[$sortOption]) && $thisEntry[$sortOption] && ($thisEntry[$sortOption] != "Title no longer available")) ? $thisEntry[$sortOption] : "~~~~~";
                $sortKey .= (isset($thisEntry["format"]) ? "" : "~~~") . $thisEntry["title"] . $thisEntry["outDate"] . $thisEntry["bibID"];
                $sortedTitles[$sortKey] = $thisEntry;
            }
            ksort($sortedTitles);
            if( $sortOption == "outDate" ) {
                $sortedTitles = array_reverse($sortedTitles);
            }
        }

        return array('historyActive'=>($readingHistory !== false), 'titles'=>$sortedTitles, 'total_records' => count($sortedTitles));
    }

    public function deleteReadingHistoryItems($patron, $selectedIDs) {
        $success = true;
        foreach( $selectedIDs as $thisID ) {
            $result = $this->makeRequest(
                ['v' . $this->apiVersion, 'patrons', $patron["id"], 'checkouts', 'history', $thisID], '', 'DELETE', $patron
            );

            if (!empty($result['code'])) {
                $success = false;
            }
        }

        // invalidate the cache
        $this->clearReadingHistoryCache($patron["id"]);

        // return info
        return $success;
    }

    public function clearReadingHistoryCache($patronID) {
        $hierarchy = ['v' . $this->apiVersion, 'patrons', $patronID, 'checkouts', 'history'];
        $offset = 0;
        $params = ['limit' => 50, 'offset' => $offset];
        $hash = md5(json_encode($hierarchy) . ($params ? ("###" . json_encode($params)) : ""));
        while( $this->memcached->get($hash) ) {
          $this->memcached->set($hash, null);
          $params['offset'] += 50;
          $hash = md5(json_encode($hierarchy) . ($params ? ("###" . json_encode($params)) : ""));
        }
        $this->memcached->delete("readingHistory" . $patronID);
        unset($this->sessionCache->readingHistory);
    }





    /**
     * Screen Scraping functionality
     *
     * The functions after this point leverage the screen scraping functionality from our previous iteration of the catalog.
     * These actions should eventually be available via the Sierra API (and as such be implemented in the Sierra2 driver), 
     * but our current version of the API does not have them available at this point.
     *
     */





    /**
     * Request PIN Reset
     *
     * This is responsible for sending the patron an email to reset their PIN.
     *
     * @param   string  $barcode    The barcode of the patron record
     * @return  mixed               True if successful, false if unsuccessful
     * @access  public
     */
    public function requestPINReset($barcode) {
        if (isset($barcode) && strlen($barcode) > 0) {
            //User has entered a barcode and requested a pin reset
            $header=array();
            $header[0] = "Accept: text/xml,application/xml,application/xhtml+xml,";
            $header[0] .= "text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5";
            $header[] = "Cache-Control: max-age=0";
            $header[] = "Connection: keep-alive";
            $header[] = "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7";
            $header[] = "Accept-Language: en-us,en;q=0.5";
            $cookie = tempnam ("/tmp", "CURLCOOKIE");

            $curl_connection = curl_init();
            curl_setopt($curl_connection, CURLOPT_CONNECTTIMEOUT, 30);
            curl_setopt($curl_connection, CURLOPT_HTTPHEADER, $header);
            curl_setopt($curl_connection, CURLOPT_USERAGENT,"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
            curl_setopt($curl_connection, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($curl_connection, CURLOPT_SSL_VERIFYPEER, false);
            curl_setopt($curl_connection, CURLOPT_FOLLOWLOCATION, true);
            curl_setopt($curl_connection, CURLOPT_UNRESTRICTED_AUTH, true);
            curl_setopt($curl_connection, CURLOPT_COOKIEJAR, $cookie);
            curl_setopt($curl_connection, CURLOPT_COOKIESESSION, true);
            curl_setopt($curl_connection, CURLOPT_FORBID_REUSE, false);
            curl_setopt($curl_connection, CURLOPT_HEADER, false);

            //Go to the pin reset page
            $curl_url = $this->config['Catalog']['classic_url'] . "/pinreset";
            curl_setopt($curl_connection, CURLOPT_URL, $curl_url);
            curl_setopt($curl_connection, CURLOPT_HTTPGET, true);
            $sresult = curl_exec($curl_connection);

            //Post the barcode to request a PIN reset email
            $post_data = array();
            $post_data['submit.x']="35";
            $post_data['submit.y']="21";
            $post_data['code']= $barcode;
            curl_setopt($curl_connection, CURLOPT_POST, true);
            curl_setopt($curl_connection, CURLOPT_URL, $curl_url);
            foreach ($post_data as $key => $value) {
                $post_items[] = $key . '=' . $value;
            }
            $post_string = implode ('&', $post_items);
            curl_setopt($curl_connection, CURLOPT_POSTFIELDS, $post_string);
            $sresult = curl_exec($curl_connection);
            if (!preg_match('/A message has been sent./i', $sresult)) {
                //PEAR::raiseError('Unable to request PIN reset for this barcode');
                return false;
            } else {
                return true;
            }
        }
    }

    /**
     * Place Item Hold
     *
     * This is responsible for both placing item level holds.
     *
     * @param   string  $recordId   The id of the bib record
     * @param   string  $itemId     The id of the item to hold
     * @param   string  $patronId   The id of the patron
     * @param   string  $comment    Any comment regarding the hold or recall
     * @param   string  $type       Whether to place a hold or recall
     * @param   string  $type       The date when the hold should be cancelled if any
     * @return  mixed               True if successful, false if unsuccessful
     *                              If an error occures, return a PEAR_Error
     * @access  public
     */
    private function placeItemLevelHold($details)
    {
        //Login to the patron's account
        $cookieJar = tempnam ("/tmp", "CURLCOOKIE");
        $success = false;

        $curl_url = $this->config['Catalog']['classic_url'] . "/patroninfo";

        $curl_connection = curl_init($curl_url);
        curl_setopt($curl_connection, CURLOPT_CONNECTTIMEOUT, 30);
        curl_setopt($curl_connection, CURLOPT_USERAGENT,"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
        curl_setopt($curl_connection, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($curl_connection, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($curl_connection, CURLOPT_FOLLOWLOCATION, 1);
        curl_setopt($curl_connection, CURLOPT_UNRESTRICTED_AUTH, true);
        curl_setopt($curl_connection, CURLOPT_COOKIEJAR, $cookieJar );
        curl_setopt($curl_connection, CURLOPT_COOKIESESSION, false);
        curl_setopt($curl_connection, CURLOPT_POST, true);
        $post_string = 'code=' . $details["patron"]["cat_username"] . '&pin=' . $details["patron"]["cat_password"]  . '&submit=submit';
        curl_setopt($curl_connection, CURLOPT_POSTFIELDS, $post_string);
        $sresult = curl_exec($curl_connection);

        list($Month, $Day, $Year)=explode("-", $details["requiredBy"]);

        // now try to request the item
        $header=array();
        $header[0] = "Accept: text/xml,application/xml,application/xhtml+xml,";
        $header[0] .= "text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5";
        $header[] = "Cache-Control: max-age=0";
        $header[] = "Connection: keep-alive";
        $header[] = "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7";
        $header[] = "Accept-Language: en-us,en;q=0.5";

        curl_setopt($curl_connection, CURLOPT_CONNECTTIMEOUT, 30);
        curl_setopt($curl_connection, CURLOPT_HTTPHEADER, $header);
        curl_setopt($curl_connection, CURLOPT_USERAGENT,"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
        curl_setopt($curl_connection, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($curl_connection, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($curl_connection, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($curl_connection, CURLOPT_UNRESTRICTED_AUTH, true);
        curl_setopt($curl_connection, CURLOPT_COOKIEJAR, $cookieJar);
        curl_setopt($curl_connection, CURLOPT_COOKIESESSION, true);
        curl_setopt($curl_connection, CURLOPT_FORBID_REUSE, false);
        curl_setopt($curl_connection, CURLOPT_HEADER, false);
        curl_setopt($curl_connection, CURLOPT_POST, true);

        $curl_url = $this->config['Catalog']['classic_url'] . "/search/.b" . $details["id"] . "/.b" . $details["id"] ."/1,1,1,B/request~b" . $details["id"];
        curl_setopt($curl_connection, CURLOPT_URL, $curl_url);

        $post_data['needby_Month']= $Month;
        $post_data['needby_Day']= $Day;
        $post_data['needby_Year']=$Year;
        $post_data['submit.x']="35";
        $post_data['submit.y']="21";
        $post_data['submit']="submit";
        $post_data['locx00']= str_pad($details["pickUpLocation"], 5/*5-strlen($details["pickUpLocation"])*/, '+');
        // BJP - we're temporarily running ALL holds through screen scraping. when that goes away, you can remove the if wrapper around the contents of this since 
        //       all holds coming through here will be item-level
        if( isset($details["item_id"]) ) {
            $post_data['radio']= "i" . $details["item_id"];
        }
        $post_data['submit']="REQUEST SELECTED ITEM";
        $post_data['x']="48";
        $post_data['y']="15";

        foreach ($post_data as $key => $value) {
            $post_items[] = $key . '=' . $value;
        }
        $post_string = implode ('&', $post_items);
        curl_setopt($curl_connection, CURLOPT_POSTFIELDS, $post_string);
        $sresult = curl_exec($curl_connection);

        $sresult = preg_replace("/<!--([^(-->)]*)-->/","",$sresult);
        curl_close($curl_connection);

        //Parse the response to get the status message
        $hold_result = $this->_getHoldResult($sresult);

        return $hold_result;
    }

    protected function _getHoldResult($holdResultPage){
        $hold_result = array();
        //Get rid of header and footer information and just get the main content
        $matches = array();

        $itemMatches = preg_match('/Choose one item from the list below/', $holdResultPage);

        if ($itemMatches == 0){
            //not prompting to select a specific item for a volume hold
            //hold responses start after the form is closed
            $responseStart = strpos($holdResultPage,'</form>');
            if ($responseStart === false) {
                $hold_result['success'] = false;
                $hold_result['status'] = '<i class=\'fa fa-exclamation-triangle\'></i>Did not receive a response from the circulation system.  Please try again in a few minutes.';
                $reason = '';
            } else {
                //get the part of the response page that contains the response to placing the hold
                $responseText = substr($holdResultPage,$responseStart);

                //Hold was successful
                if (strpos($responseText,'was successful') > 1 && strpos($responseText,'You will be notified when the status of this item says Ready For Pickup') > 0) {
                    $hold_result['success'] = true;
                    $hold_result['status'] = '<i class=\'fa fa-info\'></i>Your request was placed successfully';
                    $reason = '';
                    //Check for reasons why a hold is not successful
                } else {
                    if (strpos($responseText,'Request denied - already requested or checked out to you') > 1) {
                        $hold_result['success'] = false;
                        $hold_result['status'] = '<i class=\'fa fa-exclamation-triangle\'></i>Already requested or checked out';
                    } elseif  (strpos($responseText,'No requestable items are available') > 1) {
                        $hold_result['success'] = false;
                        $hold_result['status'] = '<i class=\'fa fa-exclamation-triangle\'></i>There are no requestable items available';
                    } elseif  (strpos($responseText,'No items requestable, request denied') > 1) {
                        $hold_result['success'] = false;
                        $hold_result['status'] = '<i class=\'fa fa-exclamation-triangle\'></i>There are no requestable items available';
                    } elseif  (strpos($responseText,'Sorry, request cannot be accepted. Local copy is available.') > 1) {
                        $hold_result['success'] = false;
                        $hold_result['status'] = '<i class=\'fa fa-exclamation-triangle\'></i>There is a copy available on the shelf at this location';
                    } elseif  (strpos($responseText,'There is a problem with your library record.  Please see a librarian') > 1) {
                        $hold_result['success'] = false;
                        $hold_result['status'] = '<i class=\'fa fa-exclamation-triangle\'></i>Your patron record is blocked or expired';
                    // generic error message
                    } else {
                        $hold_result['success'] = false;
                        $hold_result['status'] = '<i class=\'fa fa-exclamation-triangle\'></i>There was an error placing your request';
                    }
                }
            }
        }else{
            $hold_result['success'] = false;
            $hold_result['status'] = '<i class=\'fa fa-exclamation-triangle\'></i>There was an error placing your request';
        }
        return $hold_result;
    }

    /**
     * Do an update or edit of reading history information.  Current actions are:
     * deleteMarked
     * deleteAll
     * exportList
     * optOut
     *
     * @param   array   $patron         The patron array
     * @param   string  $action         The action to perform
     * @param   array   $selectedTitles The titles to do the action on if applicable
     */
    function doReadingHistoryAction($patron, $action, $selectedTitles){
        $curl_url = $this->config['Catalog']['classic_url'] . "/patroninfo~S1/" . $patron['id'] ."/readinghistory";

        $cookie = tempnam ("/tmp", "CURLCOOKIE");
        $curl_connection = curl_init($curl_url);
        curl_setopt($curl_connection, CURLOPT_CONNECTTIMEOUT, 30);
        curl_setopt($curl_connection, CURLOPT_USERAGENT,"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
        curl_setopt($curl_connection, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($curl_connection, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($curl_connection, CURLOPT_FOLLOWLOCATION, 1);
        curl_setopt($curl_connection, CURLOPT_UNRESTRICTED_AUTH, true);
        curl_setopt($curl_connection, CURLOPT_COOKIEJAR, $cookie);
        curl_setopt($curl_connection, CURLOPT_COOKIESESSION, true);
        curl_setopt($curl_connection, CURLOPT_POST, true);
        $post_string = 'code=' . $patron['cat_username'] . '&pin=' . $patron['cat_password'] . '&submit=submit';//implode ('&', $post_items);
        curl_setopt($curl_connection, CURLOPT_POSTFIELDS, $post_string);
        $sresult = curl_exec($curl_connection);

        if ($action == 'optOut'){
            //load patron page readinghistory/OptOut
            $curl_url = $this->config['Catalog']['classic_url'] . "/patroninfo~S1/" . $patron['id'] ."/readinghistory/OptOut";
            curl_setopt($curl_connection, CURLOPT_URL, $curl_url);
            curl_setopt($curl_connection, CURLOPT_HTTPGET, true);
            $sresult = curl_exec($curl_connection);

            // invalidate the cache
            $this->clearReadingHistoryCache($patron["id"]);
        }elseif ($action == 'optIn'){
            //load patron page readinghistory/OptIn
            $curl_url = $this->config['Catalog']['classic_url'] . "/patroninfo~S1}/" . $patron['id'] ."/readinghistory/OptIn";
            curl_setopt($curl_connection, CURLOPT_URL, $curl_url);
            curl_setopt($curl_connection, CURLOPT_HTTPGET, true);
            $sresult = curl_exec($curl_connection);

            // invalidate the cache
            $this->clearReadingHistoryCache($patron["id"]);
        }
        curl_close($curl_connection);

        return $sresult;
    }
}